---
title: "Data Collection"
format: html
editor: visual
---

```{r}
#| include: false
#| warning: false

# Load Libraries
libraries <- c("janitor", "tidyverse", "sf", "here", "shiny", 'DT','shinythemes')
lapply(libraries, function(x) {
    if (!require(x, character.only = TRUE)) {
        install.packages(x)
        library(x, character.only = TRUE)
    }
})


```

```{r}
# Function to Read Spatial Data (Shapefiles or GeoPackage) and Check/Reproject CRS
read_spatial_data_and_check_crs <- function(file_path, layer = NULL, target_crs = 2229) { # EPSG code for NAD83 / California zone 5 (ftUS)
  if (!is.null(layer)) {
    # Read GeoPackage layer
    sf_object <- st_read(here(file_path), layer = layer)
  } else {
    # Read shapefile or GeoPackage file
    sf_object <- st_read(here(file_path))
  }
  
  # Set the target CRS
  target_crs <- st_crs(paste0("EPSG:", target_crs))
  
  # Check if the CRS of the sf_object is not the target CRS
  if (!identical(st_crs(sf_object), target_crs)) {
    message("Reprojecting ", file_path, ifelse(!is.null(layer), paste0(" (Layer: ", layer, ")"), ""), " to ", target_crs$proj4string)
    sf_object <- st_transform(sf_object, crs = target_crs)
  } else {
    message(file_path, ifelse(!is.null(layer), paste0(" (Layer: ", layer, ")"), ""), " is already in the target CRS (", target_crs$proj4string, ").")
  }
  
  return(sf_object)
}



```

```{r}
# Initialize a vector to store variable names
created_variables <- c()

# Function to create a variable name from a filename
create_var_name <- function(filename) {
  gsub("\\.(?:shp|gpkg)$", "", basename(filename))
}

# Iterate through each subfolder in the 'data' directory
subfolders <- list.dirs(here("data"), full.names = TRUE, recursive = FALSE)

for (folder in subfolders) {
  # List all shapefiles and GeoPackage files in the subfolder
  files <- list.files(folder, pattern = "\\.(?:shp|gpkg)$", full.names = TRUE)
  
  # Read each file and assign to a variable
  for (file in files) {
    var_name <- create_var_name(file)
    
    if (grepl("\\.shp$", file)) {
      # Read shapefile and check CRS
      shapefile_data <- read_spatial_data_and_check_crs(file)
      assign(var_name, shapefile_data, envir = .GlobalEnv)
    } else if (grepl("\\.gpkg$", file)) {
      # Read GeoPackage file
      layers <- st_layers(file)
      layer_names <- layers$name
      
      for (layer_name in layer_names) {
        # Read GeoPackage layer and check CRS
        geopackage_data <- read_spatial_data_and_check_crs(file, layer = layer_name)
        
        geopackage_var_name <- paste(var_name, layer_name, sep = "_")
        assign(geopackage_var_name, geopackage_data, envir = .GlobalEnv)
        created_variables <- c(created_variables, geopackage_var_name)
      }
    }
    
    created_variables <- c(created_variables, var_name)
  }
}
```

```{r}
# Print the created variable names
"Variables created for shapefiles:"
created_variables
```


```{r}
# Define the standard columns
standard_columns <- c("Agency", "DtAcqrd", "Acreage", "TF_DYS", "PrjctNm", "TrtmntT", "DtComplt", "Other")

# UI with Dynamic Text Inputs
ui <- fluidPage(
  #includeCSS(here("www","styles.css")),  # Link to your CSS file
  #shinythemes::themeSelector(),# theme selector is only meant to be used while developing an application
  theme = shinytheme("readable"),
  titlePanel("Shapefile Data Processor"),
  
  # Conditional Panel for Login
  conditionalPanel(
    condition = "output.currentPanel === 'login'",
    wellPanel(
      textInput("user_name", "Enter your name:", ""),
      radioButtons("action_type", "Choose action:",
                   choices = c("Start New Shapefile" = "new", "Update Existing Shapefile" = "update")),

      conditionalPanel(
        condition = "input.action_type == 'update'",
        selectInput("shapefile_to_update", "Select Shapefile to Update:", choices = NULL),
        selectInput("update_with_shapefile", "Update With Shapefile:", choices = NULL),
        radioButtons("update_action", "Update Action:",
               choices = c("Add Data" = "add", "Replace Section" = "replace")),
        uiOutput("orgnlSN_selector")
      ),
      actionButton("login", "Login", disabled = TRUE)
    )
  ),
  
  # New Shapefile Modify Values Page
  conditionalPanel(
    condition = "output.currentPanel === 'modifyValues'",
    fluidRow(
      column(12,
             tags$h3("Modify individual cells or columns in the selected shapefile. Raw Data is NOT altered"),
             tags$p("Please select a file from the dropdown menu below to begin. You can modify individual cells by double clicking on the cell or entire columns in the selected shapefile. Columns with more 10 unique values are restricted from large chages as these are generally numerical columns. Column changes require pressing 'Update Column Value' buton while cell changes are instantenous. Attempting to modify the geometry will crash the application. No current UNDO button so if an error is made you'll have to start over. Click the 'Next Page' button to proceed to the column mapping page."),
      )
    ),
    sidebarLayout(
      sidebarPanel(
        selectInput("shapefile", "Select a Shapefile:", choices = NULL),
        selectInput("columnToModify", "Select Column to Modify:", choices = NULL),
        uiOutput("uniqueValuesUI"),
        uiOutput("newValueUI"),
        actionButton("updateColumnValue", "Update Column Value"),
        actionButton("columnMapping", "Next Page"),
        uiOutput("info"),
        tableOutput("changeLogTable")
      ),
      mainPanel(
        DTOutput("dataPreview")
      )
    )
  ),
  
  # Column Mapping Page
  conditionalPanel(
    condition = "output.currentPanel === 'columnMapping'",
        fluidRow(
      column(12,
             tags$h3("Map columns from the selected shapefile to the standard columns. You can also enter values manually for each column."),
             tags$p("Please select a file from the dropdown menu below to begin. You can map columns from the selected shapefile to the standard columns or enter values manually. When entering values manually the entire column will have the entered data value. Click the 'Process Data' button to stage your processed data. If creating a new shapefile then proceed to the your next choice in the dropdown. Click the 'Create New Shapefile' button to create a new shapefile with the processed data."),
      )
    ),
    sidebarLayout(
      sidebarPanel(
        selectInput("shapefile_mapping", "Select a Shapefile:", choices = NULL),
        uiOutput("column_mapping_ui"),
        actionButton("process", "Process Data"),
        actionButton("create_shapefile", "Create New Shapefile")
      ),
      mainPanel(
        DTOutput('data_preview'),
        DTOutput("processed_data")
      )
    )
  )
)

server <- function(input, output, session) {
  login_status <- reactiveVal(FALSE)
  selected_shapefile <- reactiveVal(NULL)
  selected_cell_value <- reactiveVal(NULL)
  panel_state <- reactiveVal("login") # Default panel state
  selected_shapefile_to_update <- reactiveVal(NULL)
  # Filter to get only 'Merged' files
  merged_files <- created_variables[grepl("^Merged", created_variables)]
  sf_files <- created_variables[!grepl("^Merged", created_variables)]
  
  # Initialize a reactive value to store changes
  change_log <- reactiveVal(data.frame(
    Type = character(),
    Column = character(),
    Row = integer(),
    OldValue = character(),
    NewValue = character(),
    stringsAsFactors = FALSE
  ))
  
  observe({
    if (!is.null(input$action_type) && input$action_type == "new") {
      login_disabled <- is.null(input$user_name) || nchar(input$user_name) == 0
    } else {
      login_disabled <- is.null(input$user_name) || nchar(input$user_name) == 0
    }
    updateActionButton(session, "login", disabled = login_disabled)
  })
  
  
  
  
  observe({
  if (panel_state() == "login") {


    updateSelectInput(session, "shapefile_to_update", choices = merged_files)
    updateSelectInput(session, "update_with_shapefile", choices = sf_files)
  }
  })


  observeEvent(input$login, {
    req(input$user_name)
    login_status(TRUE)
    panel_state("modifyValues") # Move to modify values panel after login
    
    if (input$action_type == "update") {
        selected_shapefile_to_update(input$update_with_shapefile)
    }
  })
  
  # Update visibility for current panel
  output$currentPanel <- reactive({ panel_state() })
  outputOptions(output, "currentPanel", suspendWhenHidden = FALSE)
  
  
  observeEvent(input$shapefile, {
        selected_shapefile(input$shapefile)
    })
  
  
  # Handle transition to column mapping panel
  observeEvent(input$columnMapping, {
    panel_state("columnMapping") # Change to column mapping panel
  })
  
  
  
  
  
  ## Populate shapefile dropdown if needed
  observe({
      if (panel_state() == "modifyValues") {
          if (!is.null(selected_shapefile_to_update())) {
              updateSelectInput(session, "shapefile", choices = selected_shapefile_to_update())
          } else {
              updateSelectInput(session, "shapefile", choices = sf_files)
          }
      }
  })
  
  # Populate shapefile dropdown on column mapping page
  observe({
      if (panel_state() == "columnMapping") {
          if (!is.null(selected_shapefile_to_update())) {
              updateSelectInput(session, "shapefile_mapping", choices = selected_shapefile_to_update())
          } else {
              updateSelectInput(session, "shapefile_mapping", choices = sf_files)
          }
      }
  })
  
  # Update selected shapefile when dropdown selection changes on column mapping page
  observeEvent(input$shapefile_mapping, {
    selected_shapefile(input$shapefile_mapping)
  })
    
    
    
    
    # Preview shapefile data
    output$dataPreview <- renderDT(server = FALSE,
                                   {
        req(selected_shapefile())
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        
        datatable(
            shapefile,
            extensions = c('Scroller'),
            options = list(scroller = TRUE,
                scrollY = 800,
                deferRender = TRUE,
                info = TRUE
            ),
            selection = list(mode = 'single', target = 'cell'),
            editable =  'cell',
            
        )
    })
    
    
    # Preview shapefile data
    output$data_preview <- renderDT(
                                   {
        req(selected_shapefile())
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        
        datatable(
            shapefile,
            extensions = c('Scroller'),
            options = list(scroller = TRUE,
                scrollY = 400,
                deferRender = TRUE,
                info = TRUE
            ),
            selection = 'none'
            
        )
    })
    
    # Populate column dropdown
    observe({
        req(selected_shapefile())
        updateSelectInput(session, "columnToModify", choices = names(get(selected_shapefile(), envir = .GlobalEnv)))
    })
    
    # Check unique values and display dropdown
    output$uniqueValuesUI <- renderUI({
        req(input$columnToModify)
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        unique_values <- unique(shapefile[[input$columnToModify]])
        if (length(unique_values) <= 10) {
            selectInput("valueToModify", "Select Value to Modify:", choices = unique_values)
        } else {
            p("The selected column has more than 10 unique values. Modification is not allowed.")
        }
    })
    
    # Display input box for new value
    output$newValueUI <- renderUI({
        req(input$valueToModify)
        textInput("newValue", "Enter New Value:")
    })
    
    # Update column value in the data
    observeEvent(input$updateColumnValue, {
        req(selected_shapefile(), input$columnToModify, input$valueToModify, input$newValue)
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        indices <- which(shapefile[[input$columnToModify]] == input$valueToModify)
        old_values <- unique(shapefile[[input$columnToModify]][indices])  # Capture unique old values
        shapefile[[input$columnToModify]][shapefile[[input$columnToModify]] == input$valueToModify] <- input$newValue
        assign(selected_shapefile(), shapefile, envir = .GlobalEnv)
        selected_shapefile(selected_shapefile())  # Trigger reactivity
        
        
        ## Log the change
        if (length(old_values) <= 10) {  # Only include old values detail if they are few
            old_value_summary <- paste(old_values, collapse = ", ")
        } else {
            old_value_summary <- paste(length(old_values), "values changed")
        }
        
        new_entry <- data.frame(
            Type = "Column",
            Column = input$columnToModify,
            RowsAffected = length(indices),
            Row = NA,
            OldValue = old_value_summary,
            NewValue = input$newValue,
            stringsAsFactors = FALSE
        )
        change_log(rbind(change_log(), new_entry))  # Append new entry to the log
    })
    
    
    
    observeEvent(input$dataPreview_cell_clicked, {
      cell_info <- input$dataPreview_cell_clicked
      
      if (!is.null(cell_info$value)) {
        value <- as.character(cell_info$value)
        selected_cell_value(value)  # Update the reactive variable
      }
    })
    
    #  Display selected cell value or unique values from selected column

    output$info <- renderUI({
      req(input$dataPreview_cells_selected)
      p(paste("Selected Cell Value:", selected_cell_value()))

    })

    #
    # Update selected cell value with new value to shapefile
    observeEvent(input$dataPreview_cell_edit, {
    info <- input$dataPreview_cell_edit
    if (is.null(info) || is.null(info$value)) return()  # Exit if no edit info

    # Retrieve the current shapefile data
    shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
    if (!"sf" %in% class(shapefile)) return()  # Check if it's an sf object

    try({
        # Adjust for zero-based index from DT and apply the new value
        row_index <- info$row   
        column_index <- info$col 
        old_value <- shapefile[row_index, column_index, drop = TRUE]
        shapefile[row_index, column_index] <- as.character(info$value)  # Convert to character if needed

        # Update the global environment and reactive value
        assign(selected_shapefile(), shapefile, envir = .GlobalEnv)
        selected_shapefile(selected_shapefile())  # Refresh reactive variable to update UI
    }, silent = TRUE)

      

    # Log changes
    new_entry <- data.frame(
        Type = "Cell",
        Column = names(shapefile)[column_index],
        RowsAffected = NA,
        Row = row_index,
        OldValue = as.character(old_value),
        NewValue = as.character(info$value),
        stringsAsFactors = FALSE
    )
    change_log(rbind(change_log(), new_entry))  # Append new entry to the log

  })
    
    
  output$changeLogTable <- renderTable({
      change_log()  # Render the change log as a table
  })





  #Reactive value to store the cumulative dataset
  cumulative_data <- reactiveVal(data.frame())

  # Update column mapping UI based on selected shapefile
  output$column_mapping_ui <- renderUI({
    req(selected_shapefile())
    shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
    #shapefile_cols <- setdiff(names(shapefile), "geometry")
    get_non_geom_columns <- function(sf_object) {
    geom_col_name <- names(st_geometry(sf_object))
    non_geom_cols <- setdiff(names(sf_object), geom_col_name)
    return(non_geom_cols)
  }
  
  # Usage
  shapefile_cols <- get_non_geom_columns(shapefile)
  
  
  
    map_ui <- lapply(standard_columns, function(col) {
      select_id <- paste0("map_", col)
      text_id <- paste0("text_", col)
      fluidRow(
        column(6, selectInput(select_id, label = paste("Map", col, "to:"),
                              choices = c("Null", shapefile_cols, "Enter value manually"))),
        column(6, uiOutput(text_id))  # Dynamic UI for text input
      )
    })
    do.call(tagList, map_ui)
  })

  # Dynamic text input based on dropdown selection
  lapply(standard_columns, function(col) {
    output[[paste0("text_", col)]] <- renderUI({
      select_id <- paste0("map_", col)
      if (!is.null(input[[select_id]]) &&
          input[[select_id]] == "Enter value manually") {
        textInput(
          paste0("manual_", col),
          label = paste("Enter value for", col),
          value = ""
        )
      }
    })
  })
  
  # Process the shapefile when the button is clicked
  observeEvent(
    input$process,
    {
      req(selected_shapefile())
      shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
      
      # Function to get value or mapped column
      get_value_or_column <- function(col_name, shapefile) {
        map_input <- input[[paste0("map_", col_name)]]
        manual_input <- input[[paste0("manual_", col_name)]]
        
        if (map_input == "Enter value manually") {
          # Use the manual input if "Enter value manually" is selected
          return(rep(manual_input, nrow(shapefile)))
        } else if (map_input != "Null") {
          # Use the selected column from the shapefile
          return(shapefile[[map_input]])
        } else {
          # Return NA if "Null" is selected
          return(rep(NA, nrow(shapefile)))
        }
      }
      
        # Get the entered username
    username <- input$user_name

    # Get the current timestamp
    timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")


    # Create a new tibble with user inputs and selected columns
    new_data <- tibble(
      OrgnlSN = selected_shapefile(),
      Agency = get_value_or_column("Agency", shapefile),
      DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
      Acreage = get_value_or_column("Acreage", shapefile),
      TF_DYS = get_value_or_column("TF_DYS", shapefile),
      PrjctNm = get_value_or_column("PrjctNm", shapefile),
      TrtmntT = get_value_or_column("TrtmntT", shapefile),
      DtComplt = get_value_or_column("DtComplt", shapefile),
      Other = get_value_or_column("Other", shapefile),
      Username = username,
      Timestamp = timestamp
    )
    #print(paste("New data dimensions:", dim(new_data)))  # Debugging statement

    # Append to the cumulative dataset
    try({
      cumulative_data(bind_rows(cumulative_data(), new_data))
    }, silent = TRUE)
  })

  
  
  
  
  output$processed_data <- renderDT({
  datatable(
    cumulative_data(),
    extensions = c('Scroller'),
    options = list(scroller = TRUE, scrollY = 800, deferRender = TRUE, info = TRUE),
    selection = 'none'
  )
})
  
  
  # Handle the creation of a new shapefile
  observeEvent(input$create_shapefile, {
    # Get the processed data
    processed_data <- cumulative_data()
    print(paste("Processed data dimensions:", dim(processed_data)))  # Debugging statement

    # Ensure there is data to process
    if (nrow(processed_data) == 0) {
        showModal(modalDialog(
            title = "No Data",
            "There is no processed data to create a shapefile."
        ))
        return()
    }
    # Access the current state of change_log
    log_data <- change_log()
    log_file_path <- here('www', "change_log.txt")

    # Check if the log_data is not empty
    if (nrow(log_data) > 0) {
        # Get the entered username
        username <- isolate(input$user_name)  # use isolate to avoid reactivity

        # Get the current timestamp
        timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")

        # Create a single line with username and timestamp
        user_time_stamp_line <- paste("User:", username, "Timestamp:", timestamp, sep = "\t")

        # Write the username and timestamp line to the file
        write_lines(user_time_stamp_line, log_file_path, append = TRUE)
        write_lines("--------------------------------------------------", log_file_path, append = TRUE)
        # Write the change log data below the username and timestamp
        write.table(
            log_data,
            log_file_path,
            sep = "\t",
            row.names = FALSE,
            col.names = !file.exists(log_file_path),  # write column names only if file doesn't exist
            quote = FALSE,
            append = TRUE
        )
        write_lines("--------------------------------------------------", log_file_path, append = TRUE)
        # Optionally, clear log_data after writing, if you don't need to accumulate the entries
        # change_log(data.frame(Type = character(), Column = character(), Row = integer(),
        #                      OldValue = character(), NewValue = character(),
        #                      stringsAsFactors = FALSE))
    }

    # Create a list to store sf objects
    sf_list <- list()

    # Loop through unique values in OrgnlSN and create sf objects
    for (sn in unique(processed_data$OrgnlSN)) {
        original_shapefile <- get(sn)
        #print(paste("Original shapefile dimensions for", sn, ":", dim(original_shapefile)))  # Debugging statement

        # Assuming the original shapefiles are 'sf' objects
        if ("sf" %in% class(original_shapefile)) {
            # Create a new sf object with processed data and original geometry
            sf_object <- st_sf(processed_data[processed_data$OrgnlSN == sn, ], geometry = original_shapefile$geometry)
            sf_list[[sn]] <- sf_object
        }
    }
    
    # Combine the sf objects
    new_shapefile <- do.call(rbind, sf_list)
    #print(paste("New shapefile dimensions:", dim(new_shapefile)))  # Debugging statement
    
    
     # Set the CRS of the new_shapefile to the target CRS
    new_shapefile <- st_set_crs(new_shapefile, st_crs(2229))
    # Get the data directory
    data_dir <- here("data","Merged")
    # Create a GeoPackage filename with the current date
    geopackage_filename <- paste0("Merged_", format(Sys.Date(), "%Y%m%d"), ".gpkg")
    # Create the full path to save the GeoPackage file
    geopackage_path <- file.path(data_dir, geopackage_filename)
    # Create a unique layer name with timestamp
    layer_name <- paste0("layer_", format(Sys.time(), "%Y%m%d_%H%M%S"))
    
    
    
    

    if (input$action_type == "new") {
    # Write the new shapefile as a new layer in the GeoPackage
    st_write(new_shapefile, geopackage_path, layer = layer_name, append = TRUE)
    
    showModal(modalDialog(
        title = "Success",
        paste("New layer added to GeoPackage:", geopackage_path, "with layer name:", layer_name)
    ))
    }  else if (input$action_type == "update") {
    # Get the selected shapefiles for updating
    shapefile_to_update <- input$shapefile_to_update
    update_with_shapefile <- new_shapefile
    
    # Read the shapefiles from the environment variables
    existing_shapefile <- get(shapefile_to_update, envir = .GlobalEnv)
    #new_shapefile_data <- processed_data
    
    # Print column names for debugging
    #print(paste("Columns in existing_shapefile:", paste(names(existing_shapefile), collapse = ", ")))
    #print(paste("Columns in new_shapefile_data:", paste(names(update_with_shapefile), collapse = ", ")))
    
    if (input$update_action == "add") {
      # Add the geometry column from the existing shapefile to the new shapefile data
      #new_shapefile_data$geom <- existing_shapefile$geom
      
      
      #Rename the geometry column to 'geom'
      st_geometry(update_with_shapefile) <- "geom"
      
      # Add the rows of the new shapefile to the existing shapefile
      updated_shapefile <- rbind(existing_shapefile, update_with_shapefile)
      
      if (is.na(st_crs(updated_shapefile))) {
        # Set the CRS if it's NA (not available)
        updated_shapefile <- st_set_crs(updated_shapefile, 2229)
      } else {
        # Transform the CRS to EPSG:2229
        updated_shapefile <- st_transform(updated_shapefile, 2229)
      }
      
      # Write the updated shapefile as a new layer in the GeoPackage
      st_write(updated_shapefile, geopackage_path, layer = layer_name, append = TRUE)
      
      showModal(modalDialog(
        title = "Success",
        paste("Rows added to new shapefile:", geopackage_path, "with layer name:", layer_name)
      ))
    } else if (input$update_action == "replace") {

      # Replace specific rows in the existing shapefile with the new shapefile data
            #Rename the geometry column to 'geom'
      st_geometry(update_with_shapefile) <- "geom"
      
      existing_shapefile <- existing_shapefile %>%
        filter(!OrgnlSN %in% unique(update_with_shapefile$OrgnlSN)) |> # Remove rows with matching OrgnlSN
        bind_rows(update_with_shapefile)  # Add the new shapefile data
      
  

      
      if (is.na(st_crs(update_with_shapefile))) {
        # Set the CRS if it's NA (not available)
        existing_shapefile <- st_set_crs(existing_shapefile, 2229)
      } else {
        # Transform the CRS to EPSG:2229
        existing_shapefile <- st_transform(existing_shapefile, 2229)
      }
      
      # Write the updated shapefile as a new layer in the GeoPackage
      st_write(existing_shapefile, geopackage_path, layer = layer_name, append = TRUE)
      
      showModal(modalDialog(
        title = "Success",
        paste("Rows replaced in new shapefile:", geopackage_path, "with layer name:", layer_name)
      ))
    }
  }
})


}


# Run the app
shinyApp(ui, server)
```


```{r}
# Define the standard columns
standard_columns <- c("Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "TrtmntT", "DtComplt", "Other")

# UI with Dynamic Text Inputs
ui <- fluidPage(
  titlePanel("Shapefile Data Processor"),
  
  # Conditional Panel for Login
  conditionalPanel(
    condition = "output.currentPanel === 'login'",
    wellPanel(
      textInput("user_name", "Enter your name:", ""),
      radioButtons("action_type", "Choose action:",
                   choices = c("Start New Shapefile" = "new", "Update Existing Shapefile" = "update")),

      conditionalPanel(
        condition = "input.action_type == 'update'",
        selectInput("shapefile_to_update", "Select Shapefile to Update:", choices = NULL),
        selectInput("update_with_shapefile", "Update With Shapefile:", choices = NULL),
        uiOutput("orgnlSN_selector")
      ),
      actionButton("login", "Login", disabled = TRUE)
    )
  ),
  
  # New Shapefile Modify Values Page
  conditionalPanel(
    condition = "output.currentPanel === 'modifyValues'",
    sidebarLayout(
      sidebarPanel(
        selectInput("shapefile", "Select a Shapefile:", choices = NULL),
        selectInput("columnToModify", "Select Column to Modify:", choices = NULL),
        uiOutput("uniqueValuesUI"),
        uiOutput("newValueUI"),
        actionButton("updateColumnValue", "Update Column Value"),
        actionButton("columnMapping", "Next Page"),
        uiOutput("info"),
        tableOutput("changeLogTable")
      ),
      mainPanel(
        DTOutput("dataPreview")
      )
    )
  ),
  
  # Column Mapping Page
  conditionalPanel(
    condition = "output.currentPanel === 'columnMapping'",
    sidebarLayout(
      sidebarPanel(
        selectInput("shapefile_mapping", "Select a Shapefile:", choices = NULL),
        uiOutput("column_mapping_ui"),
        actionButton("process", "Process Data"),
        actionButton("create_shapefile", "Create New Shapefile")
      ),
      mainPanel(
        DTOutput('data_preview'),
        DTOutput("processed_data")
      )
    )
  )
)

server <- function(input, output, session) {
  login_status <- reactiveVal(FALSE)
  selected_shapefile <- reactiveVal(NULL)
  selected_cell_value <- reactiveVal(NULL)
  panel_state <- reactiveVal("login") # Default panel state
  
  # Initialize a reactive value to store changes
  change_log <- reactiveVal(data.frame(
    Type = character(),
    Column = character(),
    Row = integer(),
    OldValue = character(),
    NewValue = character(),
    stringsAsFactors = FALSE
  ))
  
  observe({
    if (!is.null(input$action_type) && input$action_type == "new") {
      login_disabled <- is.null(input$user_name) || nchar(input$user_name) == 0
    } else {
      login_disabled <- is.null(input$user_name) || nchar(input$user_name) == 0
    }
    updateActionButton(session, "login", disabled = login_disabled)
  })
  
  observeEvent(input$login, {
    req(input$user_name)
    login_status(TRUE)
    panel_state("modifyValues") # Move to modify values panel after login
  })
  
  # Update visibility for current panel
  output$currentPanel <- reactive({ panel_state() })
  outputOptions(output, "currentPanel", suspendWhenHidden = FALSE)
  
  # Handle transition to column mapping panel
  observeEvent(input$columnMapping, {
    panel_state("columnMapping") # Change to column mapping panel
  })
  
  # Populate shapefile dropdown if needed
  observe({
    if (panel_state() == "modifyValues") {
      updateSelectInput(session, "shapefile", choices = created_variables) # Assuming 'created_variables' is defined and available
    }
  })
  
    
    observeEvent(input$shapefile, {
        selected_shapefile(input$shapefile)
    })
    
    
    
    
    # Populate shapefile dropdown on column mapping page
  observe({
    if (panel_state() == "columnMapping") {
      updateSelectInput(session, "shapefile_mapping", choices = created_variables)
    }
  })
  
  # Update selected shapefile when dropdown selection changes on column mapping page
  observeEvent(input$shapefile_mapping, {
    selected_shapefile(input$shapefile_mapping)
  })
    
    
    
    
    # Preview shapefile data
    output$dataPreview <- renderDT(server = FALSE,
                                   {
        req(selected_shapefile())
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        
        datatable(
            shapefile,
            extensions = c('Scroller'),
            options = list(scroller = TRUE,
                scrollY = 800,
                deferRender = TRUE,
                info = TRUE
            ),
            selection = list(mode = 'single', target = 'cell'),
            editable =  'cell',
            
        )
    })
    
    
    # Preview shapefile data
    output$data_preview <- renderDT(
                                   {
        req(selected_shapefile())
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        
        datatable(
            shapefile,
            extensions = c('Scroller'),
            options = list(scroller = TRUE,
                scrollY = 400,
                deferRender = TRUE,
                info = TRUE
            ),
            selection = 'none'
            
        )
    })
    
    # Populate column dropdown
    observe({
        req(selected_shapefile())
        updateSelectInput(session, "columnToModify", choices = names(get(selected_shapefile(), envir = .GlobalEnv)))
    })
    
    # Check unique values and display dropdown
    output$uniqueValuesUI <- renderUI({
        req(input$columnToModify)
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        unique_values <- unique(shapefile[[input$columnToModify]])
        if (length(unique_values) <= 10) {
            selectInput("valueToModify", "Select Value to Modify:", choices = unique_values)
        } else {
            p("The selected column has more than 10 unique values. Modification is not allowed.")
        }
    })
    
    # Display input box for new value
    output$newValueUI <- renderUI({
        req(input$valueToModify)
        textInput("newValue", "Enter New Value:")
    })
    
    # Update column value in the data
    observeEvent(input$updateColumnValue, {
        req(selected_shapefile(), input$columnToModify, input$valueToModify, input$newValue)
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        indices <- which(shapefile[[input$columnToModify]] == input$valueToModify)
        old_values <- unique(shapefile[[input$columnToModify]][indices])  # Capture unique old values
        shapefile[[input$columnToModify]][shapefile[[input$columnToModify]] == input$valueToModify] <- input$newValue
        assign(selected_shapefile(), shapefile, envir = .GlobalEnv)
        selected_shapefile(selected_shapefile())  # Trigger reactivity
        
        
        ## Log the change
        if (length(old_values) <= 10) {  # Only include old values detail if they are few
            old_value_summary <- paste(old_values, collapse = ", ")
        } else {
            old_value_summary <- paste(length(old_values), "values changed")
        }
        
        new_entry <- data.frame(
            Type = "Column",
            Column = input$columnToModify,
            RowsAffected = length(indices),
            Row = NA,
            OldValue = old_value_summary,
            NewValue = input$newValue,
            stringsAsFactors = FALSE
        )
        change_log(rbind(change_log(), new_entry))  # Append new entry to the log
    })
    
    
    
    observeEvent(input$dataPreview_cell_clicked, {
      cell_info <- input$dataPreview_cell_clicked
      
      if (!is.null(cell_info$value)) {
        value <- as.character(cell_info$value)
        selected_cell_value(value)  # Update the reactive variable
      }
    })
    
    #  Display selected cell value or unique values from selected column

    output$info <- renderUI({
      req(input$dataPreview_cells_selected)
      p(paste("Selected Cell Value:", selected_cell_value()))

    })

    #
    # Update selected cell value with new value to shapefile
    observeEvent(input$dataPreview_cell_edit, {
    info <- input$dataPreview_cell_edit
    if (is.null(info) || is.null(info$value)) return()  # Exit if no edit info

    # Retrieve the current shapefile data
    shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
    if (!"sf" %in% class(shapefile)) return()  # Check if it's an sf object

    try({
        # Adjust for zero-based index from DT and apply the new value
        row_index <- info$row   
        column_index <- info$col 
        old_value <- shapefile[row_index, column_index, drop = TRUE]
        shapefile[row_index, column_index] <- as.character(info$value)  # Convert to character if needed

        # Update the global environment and reactive value
        assign(selected_shapefile(), shapefile, envir = .GlobalEnv)
        selected_shapefile(selected_shapefile())  # Refresh reactive variable to update UI
    }, silent = TRUE)

      

    # Log changes
    new_entry <- data.frame(
        Type = "Cell",
        Column = names(shapefile)[column_index],
        RowsAffected = NA,
        Row = row_index,
        OldValue = as.character(old_value),
        NewValue = as.character(info$value),
        stringsAsFactors = FALSE
    )
    change_log(rbind(change_log(), new_entry))  # Append new entry to the log

  })
    
    
  output$changeLogTable <- renderTable({
      change_log()  # Render the change log as a table
  })





  #Reactive value to store the cumulative dataset
  cumulative_data <- reactiveVal(data.frame())

  # Update column mapping UI based on selected shapefile
  output$column_mapping_ui <- renderUI({
    req(selected_shapefile())
    shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
    shapefile_cols <- setdiff(names(shapefile), "geometry")

    map_ui <- lapply(standard_columns, function(col) {
      select_id <- paste0("map_", col)
      text_id <- paste0("text_", col)
      fluidRow(
        column(6, selectInput(select_id, label = paste("Map", col, "to:"),
                              choices = c("Null", shapefile_cols, "Enter value manually"))),
        column(6, uiOutput(text_id))  # Dynamic UI for text input
      )
    })
    do.call(tagList, map_ui)
  })

  # Dynamic text input based on dropdown selection
  lapply(standard_columns, function(col) {
    output[[paste0("text_", col)]] <- renderUI({
      select_id <- paste0("map_", col)
      if(!is.null(input[[select_id]]) && input[[select_id]] == "Enter value manually") {
        textInput(paste0("manual_", col), label = paste("Enter value for", col), value = "")
      }
    })
  })

  # Process the shapefile when the button is clicked
  observeEvent(input$process, {
    req(selected_shapefile())
    shapefile <- get(selected_shapefile(), envir = .GlobalEnv)

    # Function to get value or mapped column
    get_value_or_column <- function(col_name, shapefile) {
      map_input <- input[[paste0("map_", col_name)]]
      manual_input <- input[[paste0("manual_", col_name)]]

      if(map_input == "Enter value manually") {
        # Use the manual input if "Enter value manually" is selected
        return(rep(manual_input, nrow(shapefile)))
      } else if(map_input != "Null") {
        # Use the selected column from the shapefile
        return(shapefile[[map_input]])
      } else {
        # Return NA if "Null" is selected
        return(rep(NA, nrow(shapefile)))
      }
    }

    # Create a new tibble with user inputs and selected columns
    new_data <- tibble(
      OrgnlSN =selected_shapefile(),
      Agency = get_value_or_column("Agency", shapefile),
      DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
      Acreage = get_value_or_column("Acreage", shapefile),
      `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
      PrjctNm = get_value_or_column("PrjctNm", shapefile),
      TrtmntT = get_value_or_column("TrtmntT", shapefile),
      DtComplt = get_value_or_column("DtComplt", shapefile),
      Other = get_value_or_column("Other", shapefile)
    )
    print(paste("New data dimensions:", dim(new_data)))  # Debugging statement

    # Append to the cumulative dataset
    try({
      cumulative_data(bind_rows(cumulative_data(), new_data))
    }, silent = TRUE)
  })

  
  
  
  
  output$processed_data <- renderDT({
  datatable(
    cumulative_data(),
    extensions = c('Scroller'),
    options = list(scroller = TRUE, scrollY = 400, deferRender = TRUE, info = TRUE),
    selection = 'none'
  )
})
  
  
# Handle the creation of a new shapefile
observeEvent(input$create_shapefile, {
    # Get the processed data
    processed_data <- cumulative_data()
    print(paste("Processed data dimensions:", dim(processed_data)))  # Debugging statement

    # Ensure there is data to process
    if (nrow(processed_data) == 0) {
        showModal(modalDialog(
            title = "No Data",
            "There is no processed data to create a shapefile."
        ))
        return()
    }

    # Get the entered username
    username <- input$user_name

    # Get the current timestamp
    timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")

    # Add username and timestamp columns to the processed data
    processed_data$Username <- username
    processed_data$Timestamp <- timestamp

    # Create a list to store sf objects
    sf_list <- list()

    # Loop through unique values in OrgnlSN and create sf objects
    for (sn in unique(processed_data$OrgnlSN)) {
        original_shapefile <- get(sn)
        print(paste("Original shapefile dimensions for", sn, ":", dim(original_shapefile)))  # Debugging statement

        # Assuming the original shapefiles are 'sf' objects
        if ("sf" %in% class(original_shapefile)) {
            # Create a new sf object with processed data and original geometry
            sf_object <- st_sf(processed_data[processed_data$OrgnlSN == sn, ], geometry = original_shapefile$geometry)
            sf_list[[sn]] <- sf_object
        }
    }

    # Combine the sf objects
    new_shapefile <- do.call(rbind, sf_list)
    print(paste("New shapefile dimensions:", dim(new_shapefile)))  # Debugging statement

    # Create a GeoPackage filename with the current date
    geopackage_filename <- paste0("Merged_", format(Sys.Date(), "%Y%m%d"), ".gpkg")

    # Create a unique layer name with timestamp
    layer_name <- paste0("layer_", format(Sys.time(), "%Y%m%d_%H%M%S"))

    # Write the new shapefile as a new layer in the GeoPackage
    st_write(new_shapefile, geopackage_filename, layer = layer_name, append = TRUE)

    showModal(modalDialog(
        title = "Success",
        paste("New layer added to GeoPackage:", geopackage_filename, "with layer name:", layer_name)
    ))
})

} 
```

```{r}
# Define the standard columns
standard_columns <- c("Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "TrtmntT", "DtComplt", "Other")

# UI with Dynamic Text Inputs
ui <- fluidPage(
    titlePanel("Shapefile Data Processor"),
    # Conditional Panel for Login
    conditionalPanel(
        condition = "output.showLoginPanel",
        wellPanel(
            textInput("user_name", "Enter your name:", ""),
            radioButtons("action_type", "Choose action:",
                         choices = c("Start New Shapefile" = "new", "Update Existing Shapefile" = "update")),
            conditionalPanel(
                condition = "input.action_type == 'new'",
                textInput("new_shapefile_name", "Enter New Shapefile Name:")
            ),
            conditionalPanel(
                condition = "input.action_type == 'update'",
                selectInput("shapefile_to_update", "Select Shapefile to Update:", choices = NULL),
                selectInput("update_with_shapefile", "Update With Shapefile:", choices = NULL),
                uiOutput("orgnlSN_selector")
            ),
            actionButton("login", "Login", disabled = TRUE)
        )
    ),
    # New Shapefile Modify Values Page
    conditionalPanel(
        condition = "input.action_type == 'new' && input.login",
        sidebarLayout(
            sidebarPanel(
                selectInput("shapefile", "Select a Shapefile:", choices = NULL),
                uiOutput("selectedUI"),
                selectInput("columnToModify", "Select Column to Modify:", choices = NULL),
                uiOutput("uniqueValuesUI"),
                uiOutput("newValueUI"),
                actionButton("updateColumnValue", "Update Column Value"),
                actionButton("columnMapping", "Next Page"),
                uiOutput("info"),
                tableOutput("changeLogTable")
            ),
            mainPanel(
                DTOutput("dataPreview")
            )
        )
    )
)

server <- function(input, output, session) {
    login_status <- reactiveVal(FALSE)
    new_shapefile_name <- reactiveVal(NULL)
    selected_shapefile <- reactiveVal(NULL)
    selected_cell_value <- reactiveVal(NULL)
    # Initialize a reactive value to store changes
    change_log <- reactiveVal(data.frame(
        Type = character(),
        Column = character(),
        Row = integer(),
        OldValue = character(),
        NewValue = character(),
        stringsAsFactors = FALSE
    ))
    
    
    
    
    
    output$showLoginPanel <- reactive({ !login_status() })
    outputOptions(output, "showLoginPanel", suspendWhenHidden = FALSE)
    
    observe({
        if (!is.null(input$action_type) && input$action_type == "new") {
            login_disabled <- is.null(input$user_name) || is.null(input$new_shapefile_name) ||
                nchar(input$user_name) == 0 || nchar(input$new_shapefile_name) == 0
        } else {
            login_disabled <- is.null(input$user_name) || nchar(input$user_name) == 0
        }
        updateActionButton(session, "login", disabled = login_disabled)
    })
    
    observeEvent(input$login, {
        req(input$user_name)
        if (input$action_type == "new") {
            req(input$new_shapefile_name)
            new_shapefile_name(input$new_shapefile_name)
        }
        login_status(TRUE)
    })
    
    # Populate shapefile dropdown
    observe({
        if (login_status() && input$action_type == "new") {
            updateSelectInput(session, "shapefile", choices = created_variables)
        }
    })
    
    observeEvent(input$shapefile, {
        selected_shapefile(input$shapefile)
    })
    
    # Preview shapefile data
    output$dataPreview <- renderDT(server = FALSE,
                                   {
        req(selected_shapefile())
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        
        datatable(
            shapefile,
            extensions = c('Scroller'),
            options = list(
               # select = list(style = 'single', items = 'cell'),
                #dom = 'Bfrtip',
                #rowId = 'auto',
                #buttons = c('selectNone', 'selectColumns', 'selectCells'),
                scroller = TRUE,
                scrollY = 800,
                deferRender = TRUE,
                info = TRUE
            ),
            selection = list(mode = 'single', target = 'cell'),
            editable =  'cell',
            
        )
    })
    
    # Populate column dropdown
    observe({
        req(selected_shapefile())
        updateSelectInput(session, "columnToModify", choices = names(get(selected_shapefile(), envir = .GlobalEnv)))
    })
    
    # Check unique values and display dropdown
    output$uniqueValuesUI <- renderUI({
        req(input$columnToModify)
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        unique_values <- unique(shapefile[[input$columnToModify]])
        if (length(unique_values) <= 10) {
            selectInput("valueToModify", "Select Value to Modify:", choices = unique_values)
        } else {
            p("The selected column has more than 10 unique values. Modification is not allowed.")
        }
    })
    
    # Display input box for new value
    output$newValueUI <- renderUI({
        req(input$valueToModify)
        textInput("newValue", "Enter New Value:")
    })
    
    # Update column value in the data
    observeEvent(input$updateColumnValue, {
        req(selected_shapefile(), input$columnToModify, input$valueToModify, input$newValue)
        shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
        indices <- which(shapefile[[input$columnToModify]] == input$valueToModify)
        old_values <- unique(shapefile[[input$columnToModify]][indices])  # Capture unique old values
        shapefile[[input$columnToModify]][shapefile[[input$columnToModify]] == input$valueToModify] <- input$newValue
        assign(selected_shapefile(), shapefile, envir = .GlobalEnv)
        selected_shapefile(selected_shapefile())  # Trigger reactivity
        
        
        ## Log the change
        if (length(old_values) <= 10) {  # Only include old values detail if they are few
            old_value_summary <- paste(old_values, collapse = ", ")
        } else {
            old_value_summary <- paste(length(old_values), "values changed")
        }
        
        new_entry <- data.frame(
            Type = "Column",
            Column = input$columnToModify,
            RowsAffected = length(indices),
            Row = NA,
            OldValue = old_value_summary,
            NewValue = input$newValue,
            stringsAsFactors = FALSE
        )
        change_log(rbind(change_log(), new_entry))  # Append new entry to the log
    })
    
    
    
    observeEvent(input$dataPreview_cell_clicked, {
      cell_info <- input$dataPreview_cell_clicked
      
      if (!is.null(cell_info$value)) {
        value <- as.character(cell_info$value)
        selected_cell_value(value)  # Update the reactive variable
      }
    })
    
    #  Display selected cell value or unique values from selected column

    output$info <- renderUI({
      req(input$dataPreview_cells_selected)
      p(paste("Selected Cell Value:", selected_cell_value()))

    })

    #
    # Update selected cell value with new value to shapefile
    observeEvent(input$dataPreview_cell_edit, {
    info <- input$dataPreview_cell_edit
    if (is.null(info) || is.null(info$value)) return()  # Exit if no edit info

    # Retrieve the current shapefile data
    shapefile <- get(selected_shapefile(), envir = .GlobalEnv)
    if (!"sf" %in% class(shapefile)) return()  # Check if it's an sf object

    try({
        # Adjust for zero-based index from DT and apply the new value
        row_index <- info$row   
        column_index <- info$col 
        old_value <- shapefile[row_index, column_index, drop = TRUE]
        shapefile[row_index, column_index] <- as.character(info$value)  # Convert to character if needed

        # Update the global environment and reactive value
        assign(selected_shapefile(), shapefile, envir = .GlobalEnv)
        selected_shapefile(selected_shapefile())  # Refresh reactive variable to update UI
    }, silent = TRUE)

      

    # Log changes
    new_entry <- data.frame(
        Type = "Cell",
        Column = names(shapefile)[column_index],
        RowsAffected = NA,
        Row = row_index,
        OldValue = as.character(old_value),
        NewValue = as.character(info$value),
        stringsAsFactors = FALSE
    )
    change_log(rbind(change_log(), new_entry))  # Append new entry to the log

  })
    
    
  output$changeLogTable <- renderTable({
      change_log()  # Render the change log as a table
  })
}

# Run the app
shinyApp(ui, server)
```

```{r}
# 
# 
# # Define the standard columns
# standard_columns <- c("Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "TrtmntT", "DtComplt", "Other")
# 
# # UI with Dynamic Text Inputs
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     # Conditional Panel for Login
#     conditionalPanel(
#         condition = "output.showLoginPanel",
#         wellPanel(
#             textInput("user_name", "Enter your name:", ""),
#             radioButtons("action_type", "Choose action:",
#                          choices = c("Start New Shapefile" = "new", "Update Existing Shapefile" = "update")),
#             conditionalPanel(
#                 condition = "input.action_type == 'new'",
#                 textInput("new_shapefile_name", "Enter New Shapefile Name:")
#             ),
#             conditionalPanel(
#                 condition = "input.action_type == 'update'",
#                 selectInput("shapefile_to_update", "Select Shapefile to Update:", choices = NULL),
#                 selectInput("update_with_shapefile", "Update With Shapefile:", choices = NULL),
#                 uiOutput("orgnlSN_selector")
#             ),
#             actionButton("login", "Login")
#         )
#     ),
#     # Main Application Panel, shown only after login
#     conditionalPanel(
#         condition = "!output.showLoginPanel",
#         sidebarLayout(
#             sidebarPanel(
#                 uiOutput("shapefile_selector"),
#                 uiOutput("modifyOptions"),
#                 actionButton("modifyData", "Modify Data"),
#                 actionButton("create_shapefile", "Create New Shapefile")
#             ),
#             mainPanel(
#                 DTOutput("dataView")
#             )
#         )
#     )
# )
# 
# 
# server <- function(input, output, session) {
#     login_status <- reactiveVal(FALSE)
#     updating_shapefile <- reactiveVal(FALSE)
#     new_shapefile_name <- reactiveVal(NULL)
# 
#     output$showLoginPanel <- reactive({ !login_status() })
#     outputOptions(output, "showLoginPanel", suspendWhenHidden = FALSE)
#     
#     # Dynamically load shapefile choices excluding the one being updated
#     observe({
#         updateSelectInput(session, "shapefile_to_update", choices = created_variables)
#         updateSelectInput(session, "update_with_shapefile", choices = setdiff(created_variables, input$shapefile_to_update))
#     })
#     
#     output$orgnlSN_selector <- renderUI({
#     req(input$shapefile_to_update)
#     
#     # Get the selected shapefile object
#     shapefile <- get(input$shapefile_to_update, envir = .GlobalEnv)
#     
#     if ("OrgnlSN" %in% names(shapefile)) {
#         # If the 'OrgnlSN' column exists in the selected shapefile
#         orgnlSN_choices <- unique(shapefile$OrgnlSN)
#     } else {
#         # If the 'OrgnlSN' column doesn't exist in the selected shapefile
#         orgnlSN_choices <- character(0)
#     }
#     
#     # Check if 'OrgnlSN' exists in other shapefiles
#     other_shapefiles <- setdiff(created_variables, input$shapefile_to_update)
#     for (sf_name in other_shapefiles) {
#         sf_object <- get(sf_name, envir = .GlobalEnv)
#         if ("OrgnlSN" %in% names(sf_object)) {
#             orgnlSN_choices <- union(orgnlSN_choices, unique(sf_object$OrgnlSN))
#         }
#     }
#     
#     if (length(orgnlSN_choices) > 0) {
#         # If 'OrgnlSN' values are found in any shapefile
#         selectInput("OrgnlSN", "Select 'OrgnlSN' to Update:", choices = orgnlSN_choices)
#     } else {
#         # If 'OrgnlSN' doesn't exist in any shapefile
#         selectInput("OrgnlSN", "Select 'OrgnlSN' to Update:", choices = character(0))
#     }}
#     )
#     
#     
#     observeEvent(input$login, {
#         req(input$user_name)
#         session$userData$user_info <- list(name = input$user_name, timestamp = Sys.time())
#         new_shapefile_name(if (input$action_type == "new") input$new_shapefile_name else NULL)
#         login_status(TRUE)
#         updating_shapefile(input$action_type == "update")
#     })
# 
#     # Handling the shapefile selection for modification
#     output$shapefile_selector <- renderUI({
#       if (updating_shapefile()) {
#         selectInput("shapefile", "Select a Shapefile:", choices = created_variables)
#       }
#     })
#     
#     output$dataView <- renderDT({
#         req(input$shapefile)
#         datatable(created_variables[[input$shapefile]], options = list(pageLength = 10))
#     })
# 
#     # Modify Options UI and further logic
#     # output$modifyOptions <- renderUI({
#     #     if (updating_shapefile()) {
#     #         # Additional UI elements and logic for updating an existing shapefile
#     #     }
#     #     # General modification options
#     # })
#     # 
# 
# 
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
# 
#     # Preview the data of the selected shapefile, excluding the geometry column
#     output$data_preview <- renderTable({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         if ("sf" %in% class(shapefile)) {
#             shapefile <- as.data.frame(shapefile)
#         }
#         head(shapefile[setdiff(names(shapefile), "geometry")])
#     })
# 
#      # Update column mapping UI based on selected shapefile
#     output$column_mapping_ui <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         shapefile_cols <- setdiff(names(shapefile), "geometry")
# 
#         map_ui <- lapply(standard_columns, function(col) {
#             select_id <- paste0("map_", col)
#             text_id <- paste0("text_", col)
#             fluidRow(
#                 column(6, selectInput(select_id, label = paste("Map", col, "to:"),
#                                       choices = c("Null", shapefile_cols, "Enter value manually"))),
#                 column(6, uiOutput(text_id))  # Dynamic UI for text input
#             )
#         })
#         do.call(tagList, map_ui)
#     })
# 
#     # Dynamic text input based on dropdown selection
#     lapply(standard_columns, function(col) {
#         output[[paste0("text_", col)]] <- renderUI({
#             select_id <- paste0("map_", col)
#             if(!is.null(input[[select_id]]) && input[[select_id]] == "Enter value manually") {
#                 textInput(paste0("manual_", col), label = paste("Enter value for", col), value = "")
#             }
#         })
#     })
# 
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
# 
#         # Function to get value or mapped column
#         get_value_or_column <- function(col_name, shapefile) {
#             map_input <- input[[paste0("map_", col_name)]]
#             manual_input <- input[[paste0("manual_", col_name)]]
# 
#             if(map_input == "Enter value manually") {
#                 # Use the manual input if "Enter value manually" is selected
#                 return(rep(manual_input, nrow(shapefile)))
#             } else if(map_input != "Null") {
#                 # Use the selected column from the shapefile
#                 return(shapefile[[map_input]])
#             } else {
#                 # Return NA if "Null" is selected
#                 return(rep(NA, nrow(shapefile)))
#             }
#         }
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = get_value_or_column("Agency", shapefile),
#             DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
#             Acreage = get_value_or_column("Acreage", shapefile),
#             `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
#             PrjctNm = get_value_or_column("PrjctNm", shapefile),
#             TrtmntT = get_value_or_column("TrtmntT", shapefile),
#             DtComplt = get_value_or_column("DtComplt", shapefile),
#             Other = get_value_or_column("Other", shapefile)
#         )
# 
#         # Append to the cumulative dataset
#         try({
#             cumulative_data(bind_rows(cumulative_data(), new_data))
#         }, silent = TRUE)
#     })
# 
#    # Handle the creation of a new shapefile
#     observeEvent(input$create_shapefile, {
#         # Get the processed data
#         processed_data <- cumulative_data()
# 
#         # Ensure there is data to process
#         if (nrow(processed_data) == 0) {
#             showModal(modalDialog(
#                 title = "No Data",
#                 "There is no processed data to create a shapefile."
#             ))
#             return()
#         }
# 
#         # Create a list to store geometries
#         geometries_list <- list()
# 
#         # Loop through unique values in OrgnlSN and get corresponding geometries
#         for (sn in unique(processed_data$OrgnlSN)) {
#             original_shapefile <- get(sn)
#             # Assuming the original shapefiles are 'sf' objects
#             if ("sf" %in% class(original_shapefile)) {
#                 geometries_list[[sn]] <- original_shapefile$geometry
#             }
#         }
# 
#         # Combine the geometries
#         combined_geometry <- do.call(rbind, geometries_list)
# 
#         # Example conversion of a boolean field to string
#         processed_data$`TF(DYS)` <- as.character(processed_data$`TF(DYS)`)
#         processed_data$DtComplt <- as.character(processed_data$DtComplt)
# 
# 
#         # Create a new shapefile with the combined geometries
#         new_shapefile <- st_sf(processed_data, geometry = st_sfc(combined_geometry))
#         st_write(new_shapefile, "new_shapefile.shp")
# 
#         showModal(modalDialog(
#             title = "Success",
#             "New shapefile created successfully."
#         ))
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)
```

```{r}

# Define the standard columns
# standard_columns <- c("Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "TrtmntT", "DtComplt", "Other")
# 
# # UI with Dynamic Text Inputs
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     # Conditional Panel for Login
#     conditionalPanel(
#         condition = "output.showLoginPanel",
#         wellPanel(
#             textInput("user_name", "Enter your name:", ""),
#             radioButtons("action_type", "Choose action:",
#                          choices = c("Start New Shapefile" = "new", "Update Existing Shapefile" = "update")),
#             conditionalPanel(
#                 condition = "input.action_type == 'new'",
#                 textInput("new_shapefile_name", "Enter New Shapefile Name:")
#             ),
#             conditionalPanel(
#                 condition = "input.action_type == 'update'",
#                 selectInput("shapefile_to_update", "Select Shapefile to Update:", choices = NULL),
#                 selectInput("update_with_shapefile", "Update With Shapefile:", choices = NULL),
#                 uiOutput("orgnlSN_selector")
#             ),
#             actionButton("login", "Login")
#         )
#     ),
#     # Main Application Panel, shown only after login
#     conditionalPanel(
#         condition = "!output.showLoginPanel",
#         sidebarLayout(
#             sidebarPanel(
#                 uiOutput("shapefile_selector"),
#                 uiOutput("modifyOptions"),
#                 actionButton("modifyData", "Modify Data"),
#                 actionButton("create_shapefile", "Create New Shapefile")
#             ),
#             mainPanel(
#                 tableOutput("dataView")  # Using simple table display
#             )
#         )
#     )
# )
# 
# 
# 
# 
# 
# 
# 
# 
# server <- function(input, output, session) {
#     login_status <- reactiveVal(FALSE)
#     updating_shapefile <- reactiveVal(FALSE)
#     new_shapefile_name <- reactiveVal(NULL)
# 
#     output$showLoginPanel <- reactive({ !login_status() })
#     outputOptions(output, "showLoginPanel", suspendWhenHidden = FALSE)
#     
#     # Populate the dropdowns for updating shapefiles dynamically
#     observe({
#         shapefiles <- names(created_variables)  # Assuming created_variables is a list of data.frames
#         updateSelectInput(session, "shapefile_to_update", choices = shapefiles)
#         updateSelectInput(session, "update_with_shapefile", choices = setdiff(shapefiles, input$shapefile_to_update))
#     })
#     
#     output$orgnlSN_selector <- renderUI({
#         req(input$shapefile_to_update)
#         selectInput("orgnlSN", "Select 'OrgnlSN' to Update:", choices = unique(created_variables[[input$shapefile_to_update]]$OrgnlSN))
#     })
# 
#     observeEvent(input$login, {
#         req(input$user_name)
#         session$userData$user_info <- list(name = input$user_name, timestamp = Sys.time())
#         new_shapefile_name(if (input$action_type == "new") input$new_shapefile_name else NULL)
#         login_status(TRUE)
#         updating_shapefile(input$action_type == "update")
#     })
# 
#     # Handling the shapefile selection for modification
#     output$shapefile_selector <- renderUI({
#         selectInput("shapefile", "Select a Shapefile:", choices = names(created_variables))
#     })
# 
#     output$dataView <- renderTable({
#         req(input$shapefile)
#         created_variables[[input$shapefile]]
#     })
# 
#     # Modify Options UI and further logic
#     output$modifyOptions <- renderUI({
#         if (updating_shapefile()) {
#             # Additional UI elements and logic for updating an existing shapefile
#         }
#         # General modification options
#     })
#     
#     
#     
#     
#     
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
#     # Preview the data of the selected shapefile, excluding the geometry column
#     output$data_preview <- renderTable({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         if ("sf" %in% class(shapefile)) {
#             shapefile <- as.data.frame(shapefile)
#         }
#         head(shapefile[setdiff(names(shapefile), "geometry")])
#     })
#     
#   
#      # Update column mapping UI based on selected shapefile
#     output$column_mapping_ui <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         shapefile_cols <- setdiff(names(shapefile), "geometry")
# 
#         map_ui <- lapply(standard_columns, function(col) {
#             select_id <- paste0("map_", col)
#             text_id <- paste0("text_", col)
#             fluidRow(
#                 column(6, selectInput(select_id, label = paste("Map", col, "to:"), 
#                                       choices = c("Null", shapefile_cols, "Enter value manually"))),
#                 column(6, uiOutput(text_id))  # Dynamic UI for text input
#             )
#         })
#         do.call(tagList, map_ui)
#     })
# 
#     # Dynamic text input based on dropdown selection
#     lapply(standard_columns, function(col) {
#         output[[paste0("text_", col)]] <- renderUI({
#             select_id <- paste0("map_", col)
#             if(!is.null(input[[select_id]]) && input[[select_id]] == "Enter value manually") {
#                 textInput(paste0("manual_", col), label = paste("Enter value for", col), value = "")
#             }
#         })
#     })
# 
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
# 
#         # Function to get value or mapped column
#         get_value_or_column <- function(col_name, shapefile) {
#             map_input <- input[[paste0("map_", col_name)]]
#             manual_input <- input[[paste0("manual_", col_name)]]
#             
#             if(map_input == "Enter value manually") {
#                 # Use the manual input if "Enter value manually" is selected
#                 return(rep(manual_input, nrow(shapefile)))
#             } else if(map_input != "Null") {
#                 # Use the selected column from the shapefile
#                 return(shapefile[[map_input]])
#             } else {
#                 # Return NA if "Null" is selected
#                 return(rep(NA, nrow(shapefile)))
#             }
#         }
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = get_value_or_column("Agency", shapefile),
#             DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
#             Acreage = get_value_or_column("Acreage", shapefile),
#             `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
#             PrjctNm = get_value_or_column("PrjctNm", shapefile),
#             TrtmntT = get_value_or_column("TrtmntT", shapefile),
#             DtComplt = get_value_or_column("DtComplt", shapefile),
#             Other = get_value_or_column("Other", shapefile)
#         )
# 
#         # Append to the cumulative dataset
#         try({
#             cumulative_data(bind_rows(cumulative_data(), new_data))
#         }, silent = TRUE)
#     })
# 
#    # Handle the creation of a new shapefile
#     observeEvent(input$create_shapefile, {
#         # Get the processed data
#         processed_data <- cumulative_data()
# 
#         # Ensure there is data to process
#         if (nrow(processed_data) == 0) {
#             showModal(modalDialog(
#                 title = "No Data",
#                 "There is no processed data to create a shapefile."
#             ))
#             return()
#         }
# 
#         # Create a list to store geometries
#         geometries_list <- list()
# 
#         # Loop through unique values in OrgnlSN and get corresponding geometries
#         for (sn in unique(processed_data$OrgnlSN)) {
#             original_shapefile <- get(sn)
#             # Assuming the original shapefiles are 'sf' objects
#             if ("sf" %in% class(original_shapefile)) {
#                 geometries_list[[sn]] <- original_shapefile$geometry
#             }
#         }
# 
#         # Combine the geometries
#         combined_geometry <- do.call(rbind, geometries_list)
#         
#         # Example conversion of a boolean field to string
#         processed_data$`TF(DYS)` <- as.character(processed_data$`TF(DYS)`)
#         processed_data$DtComplt <- as.character(processed_data$DtComplt)
# 
# 
#         # Create a new shapefile with the combined geometries
#         new_shapefile <- st_sf(processed_data, geometry = st_sfc(combined_geometry))
#         st_write(new_shapefile, "new_shapefile.shp")
# 
#         showModal(modalDialog(
#             title = "Success",
#             "New shapefile created successfully."
#         ))
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)
```

```{r}
# # RShiny
# 
# # UI
# ui <- fluidPage(
#     titlePanel("Shapefile Column Selector"),
#     sidebarLayout(
#         sidebarPanel(
#             selectInput("shapefile", "Select a Shapefile:", choices = created_variables),
#             uiOutput("column_selector")
#         ),
#         mainPanel(
#             tableOutput("selected_data")
#         )
#     )
# )
# 
# # Server logic
# server <- function(input, output, session) {
#     
#     # Update column selector based on selected shapefile
#     output$column_selector <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         checkboxGroupInput("columns", "Select Columns:", choices = names(shapefile))
#     })
# 
#     # Observe changes in the selected shapefile and update available columns
#     observe({
#         shapefile <- get(input$shapefile)
#         updateCheckboxGroupInput(session, "columns", 
#                                  choices = names(shapefile), selected = NULL)
#     })
# 
#     # Render the table based on selected columns
#     output$selected_data <- renderTable({
#         req(input$shapefile, input$columns)
#         shapefile <- get(input$shapefile)
#         
#         # Handle spatial data (sf objects) by converting to a regular data frame
#         if ("sf" %in% class(shapefile)) {
#             shapefile <- as.data.frame(shapefile)
#         }
#         
#         # Safely select columns, avoiding errors if columns don't exist
#         safe_cols <- intersect(input$columns, names(shapefile))
#         shapefile[, safe_cols, drop = FALSE]
#     }, error = function(e) { 
#         # Handle errors in table rendering
#         "Error in rendering table"
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)

```

```{r}
# 
# # Define the UI
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     sidebarLayout(
#         sidebarPanel(
#             selectInput("shapefile", "Select a Shapefile:", choices = created_variables),
#             uiOutput("column_selector"),
#             textInput("agency", "Agency", ""),
#             textInput("dtAcqrd", "Date Acquired", ""),
#             textInput("tfDays", "Timeframe (Days)", ""),
#             textInput("prjctNm", "Project Name", ""),
#             textInput("TrtmnT", "Treatment", ""),
#             textInput("dtComplt", "Date Completed", ""),
#             textInput("other", "Other", ""),
#             actionButton("process", "Process Shapefile")
#         ),
#         mainPanel(
#             tableOutput("processed_data")
#         )
#     )
# )
# 
# # Define server logic
# server <- function(input, output, session) {
#     
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
# 
#     # Update column selector based on selected shapefile
#     output$column_selector <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         checkboxGroupInput("columns", "Select Columns:", choices = names(shapefile))
#     })
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile, input$columns)
#         shapefile <- get(input$shapefile) %>% select(all_of(input$columns))
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = input$agency,
#             DtAcqrd = input$dtAcqrd,
#             Acreage = shapefile$Acres,  # Assuming 'Acres' is a common column
#             TF_DYS = input$tfDays,
#             PrjctNm = input$prjctNm,
#             DtComplt = input$dtComplt,
#             Other = input$other
#         )
# 
#         # Append to the cumulative dataset
#         cumulative_data(bind_rows(cumulative_data(), new_data))
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)
```

```{r}
# standard_columns <- c( "Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "DtComplt", "Other")
# 
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     sidebarLayout(
#         sidebarPanel(
#             selectInput("shapefile", "Select a Shapefile:", choices = created_variables),
#             uiOutput("column_mapping_ui"),
#             actionButton("process", "Process Shapefile")
#         ),
#         mainPanel(
#             tableOutput("processed_data")
#         )
#     )
# )
# 
# server <- function(input, output, session) {
#     
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
# 
#     # Update column mapping UI based on selected shapefile
#     output$column_mapping_ui <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         shapefile_cols <- names(shapefile)
# 
#         # Create UI elements for each standard column
#         map_ui <- lapply(standard_columns, function(col) {
#             fluidRow(
#                 column(6, selectInput(paste0("select_", col), 
#                                       label = paste("Map", col, "to:"), 
#                                       choices = c("Enter value", shapefile_cols))),
#                 column(6, textInput(paste0("text_", col), 
#                                     label = paste("Or enter value for", col), 
#                                     value = ""))
#             )
#         })
#         do.call(tagList, map_ui)
#     })
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
# 
#         # Function to get value or mapped column
#         get_value_or_column <- function(col_name, shapefile) {
#             select_input <- input[[paste0("select_", col_name)]]
#             text_input <- input[[paste0("text_", col_name)]]
#             
#             if(select_input != "Enter value") {
#                 return(shapefile[[select_input]])
#             } else {
#                 return(rep(text_input, nrow(shapefile)))
#             }
#         }
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = get_value_or_column("Agency", shapefile),
#             DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
#             Acreage = get_value_or_column("Acreage", shapefile),
#             `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
#             PrjctNm = get_value_or_column("PrjctNm", shapefile),
#             DtComplt = get_value_or_column("DtComplt", shapefile),
#             Other = get_value_or_column("Other", shapefile)
#         )
# 
#         # Append to the cumulative dataset
#         cumulative_data(bind_rows(cumulative_data(), new_data))
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)

```

```{r}
# standard_columns <- c( "Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "DtComplt", "Other")
# 
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     sidebarLayout(
#         sidebarPanel(
#             selectInput("shapefile", "Select a Shapefile:", choices = created_variables),
#             uiOutput("column_mapping_ui"),
#             actionButton("process", "Process Shapefile")
#         ),
#         mainPanel(
#             tableOutput("data_preview"),
#             tableOutput("processed_data")
#         )
#     )
# )
# 
# server <- function(input, output, session) {
#     
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
# 
#     # Preview the data of the selected shapefile
#     output$data_preview <- renderTable({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         head(shapefile)  # Show first few rows
#     })
# 
#     # Update column mapping UI based on selected shapefile
#     output$column_mapping_ui <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         shapefile_cols <- c("Enter value manually", names(shapefile))
# 
#         # Create UI elements for each standard column
#         map_ui <- lapply(standard_columns, function(col) {
#             selectInput(paste0("map_", col), 
#                         label = paste("Map", col, "to:"), 
#                         choices = shapefile_cols)
#         })
#         do.call(tagList, map_ui)
#     })
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
# 
#         # Function to get value or mapped column
#         get_value_or_column <- function(col_name, shapefile) {
#             map_input <- input[[paste0("map_", col_name)]]
#             
#             if(map_input == "Enter value manually") {
#                 return(rep(NA, nrow(shapefile)))  # Replace with user input if needed
#             } else {
#                 return(shapefile[[map_input]])
#             }
#         }
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = get_value_or_column("Agency", shapefile),
#             DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
#             Acreage = get_value_or_column("Acreage", shapefile),
#             `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
#             PrjctNm = get_value_or_column("PrjctNm", shapefile),
#             DtComplt = get_value_or_column("DtComplt", shapefile),
#             Other = get_value_or_column("Other", shapefile)
#         )
# 
#         # Append to the cumulative dataset
#         try({
#             cumulative_data(bind_rows(cumulative_data(), new_data))
#         }, silent = TRUE)
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)

```

```{r}
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     sidebarLayout(
#         sidebarPanel(
#             selectInput("shapefile", "Select a Shapefile:", choices = created_variables),
#             uiOutput("column_mapping_ui"),
#             actionButton("process", "Process Shapefile"),
#             actionButton("create_shapefile", "Create New Shapefile")
#         ),
#         mainPanel(
#             tableOutput("data_preview"),
#             tableOutput("processed_data")
#         )
#     )
# )
# server <- function(input, output, session) {
#     
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
# 
#     # Preview the data of the selected shapefile, excluding the geometry column
#     output$data_preview <- renderTable({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         if ("sf" %in% class(shapefile)) {
#             shapefile <- as.data.frame(shapefile)
#         }
#         head(shapefile[setdiff(names(shapefile), "geometry")])
#     })
# 
#     # Update column mapping UI based on selected shapefile
#     output$column_mapping_ui <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         shapefile_cols <- c("Enter value manually", setdiff(names(shapefile), "geometry"))
# 
#         # Create UI elements for each standard column
#         map_ui <- lapply(standard_columns, function(col) {
#             selectInput(paste0("map_", col), 
#                         label = paste("Map", col, "to:"), 
#                         choices = shapefile_cols)
#         })
#         do.call(tagList, map_ui)
#     })
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
# 
#         # Function to get value or mapped column
#         get_value_or_column <- function(col_name, shapefile) {
#             map_input <- input[[paste0("map_", col_name)]]
#             
#             if(map_input == "Enter value manually") {
#                 return(rep(NA, nrow(shapefile)))  # Replace with user input if needed
#             } else {
#                 return(shapefile[[map_input]])
#             }
#         }
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = get_value_or_column("Agency", shapefile),
#             DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
#             Acreage = get_value_or_column("Acreage", shapefile),
#             `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
#             PrjctNm = get_value_or_column("PrjctNm", shapefile),
#             DtComplt = get_value_or_column("DtComplt", shapefile),
#             Other = get_value_or_column("Other", shapefile)
#         )
# 
#         # Append to the cumulative dataset
#         try({
#             cumulative_data(bind_rows(cumulative_data(), new_data))
#         }, silent = TRUE)
#     })
# 
#     # Handle the creation of a new shapefile
#     observeEvent(input$create_shapefile, {
#         # Logic to create a new shapefile based on the processed data
#         # This will be implemented as per your requirements
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)

```

```{r}
# # Define the standard columns
# standard_columns <- c("Agency", "DtAcqrd", "Acreage", "TF(DYS)", "PrjctNm", "TrtmntT", "DtComplt", "Other")
# 
# # UI with Dynamic Text Inputs
# ui <- fluidPage(
#     titlePanel("Shapefile Data Processor"),
#     sidebarLayout(
#         sidebarPanel(
#             selectInput("shapefile", "Select a Shapefile:", choices = created_variables),
#             uiOutput("column_mapping_ui"),
#             actionButton("process", "Process Shapefile"),
#             actionButton("create_shapefile", "Create New Shapefile")
#         ),
#         mainPanel(
#             tableOutput("data_preview"),
#             tableOutput("processed_data")
#         )
#     )
# )
# 
# server <- function(input, output, session) {
#     
#     # Reactive value to store the cumulative dataset
#     cumulative_data <- reactiveVal(data.frame())
# 
#     # Preview the data of the selected shapefile, excluding the geometry column
#     output$data_preview <- renderTable({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         if ("sf" %in% class(shapefile)) {
#             shapefile <- as.data.frame(shapefile)
#         }
#         head(shapefile[setdiff(names(shapefile), "geometry")])
#     })
# 
#      # Update column mapping UI based on selected shapefile
#     output$column_mapping_ui <- renderUI({
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
#         shapefile_cols <- setdiff(names(shapefile), "geometry")
# 
#         map_ui <- lapply(standard_columns, function(col) {
#             select_id <- paste0("map_", col)
#             text_id <- paste0("text_", col)
#             fluidRow(
#                 column(6, selectInput(select_id, label = paste("Map", col, "to:"), 
#                                       choices = c("Null", shapefile_cols, "Enter value manually"))),
#                 column(6, uiOutput(text_id))  # Dynamic UI for text input
#             )
#         })
#         do.call(tagList, map_ui)
#     })
# 
#     # Dynamic text input based on dropdown selection
#     lapply(standard_columns, function(col) {
#         output[[paste0("text_", col)]] <- renderUI({
#             select_id <- paste0("map_", col)
#             if(!is.null(input[[select_id]]) && input[[select_id]] == "Enter value manually") {
#                 textInput(paste0("manual_", col), label = paste("Enter value for", col), value = "")
#             }
#         })
#     })
# 
# 
#     # Process the shapefile when the button is clicked
#     observeEvent(input$process, {
#         req(input$shapefile)
#         shapefile <- get(input$shapefile)
# 
#         # Function to get value or mapped column
#         get_value_or_column <- function(col_name, shapefile) {
#             map_input <- input[[paste0("map_", col_name)]]
#             manual_input <- input[[paste0("manual_", col_name)]]
#             
#             if(map_input == "Enter value manually") {
#                 # Use the manual input if "Enter value manually" is selected
#                 return(rep(manual_input, nrow(shapefile)))
#             } else if(map_input != "Null") {
#                 # Use the selected column from the shapefile
#                 return(shapefile[[map_input]])
#             } else {
#                 # Return NA if "Null" is selected
#                 return(rep(NA, nrow(shapefile)))
#             }
#         }
# 
#         # Create a new tibble with user inputs and selected columns
#         new_data <- tibble(
#             OrgnlSN = input$shapefile,
#             Agency = get_value_or_column("Agency", shapefile),
#             DtAcqrd = get_value_or_column("DtAcqrd", shapefile),
#             Acreage = get_value_or_column("Acreage", shapefile),
#             `TF(DYS)` = get_value_or_column("TF(DYS)", shapefile),
#             PrjctNm = get_value_or_column("PrjctNm", shapefile),
#             TrtmntT = get_value_or_column("TrtmntT", shapefile),
#             DtComplt = get_value_or_column("DtComplt", shapefile),
#             Other = get_value_or_column("Other", shapefile)
#         )
# 
#         # Append to the cumulative dataset
#         try({
#             cumulative_data(bind_rows(cumulative_data(), new_data))
#         }, silent = TRUE)
#     })
# 
#    # Handle the creation of a new shapefile
#     observeEvent(input$create_shapefile, {
#         # Get the processed data
#         processed_data <- cumulative_data()
# 
#         # Ensure there is data to process
#         if (nrow(processed_data) == 0) {
#             showModal(modalDialog(
#                 title = "No Data",
#                 "There is no processed data to create a shapefile."
#             ))
#             return()
#         }
# 
#         # Create a list to store geometries
#         geometries_list <- list()
# 
#         # Loop through unique values in OrgnlSN and get corresponding geometries
#         for (sn in unique(processed_data$OrgnlSN)) {
#             original_shapefile <- get(sn)
#             # Assuming the original shapefiles are 'sf' objects
#             if ("sf" %in% class(original_shapefile)) {
#                 geometries_list[[sn]] <- original_shapefile$geometry
#             }
#         }
# 
#         # Combine the geometries
#         combined_geometry <- do.call(rbind, geometries_list)
#         
#         # Example conversion of a boolean field to string
#         processed_data$`TF(DYS)` <- as.character(processed_data$`TF(DYS)`)
#         processed_data$DtComplt <- as.character(processed_data$DtComplt)
# 
# 
#         # Create a new shapefile with the combined geometries
#         new_shapefile <- st_sf(processed_data, geometry = st_sfc(combined_geometry))
#         st_write(new_shapefile, "new_shapefile.shp")
# 
#         showModal(modalDialog(
#             title = "Success",
#             "New shapefile created successfully."
#         ))
#     })
# 
#     # Display the processed data
#     output$processed_data <- renderTable({
#         cumulative_data()
#     })
# }
# 
# # Run the app
# shinyApp(ui, server)
```

```{r}
# new_shape <-  sf::st_read("new_shapefile.gpkg")
# 
# ag <-  sf::st_read(here('data','Ag_Greenbelts_02182021', 'Ag_Greenbelts_02182021.shp'))
# 
# Camino_Cielo_Fuelbreak <-  sf::st_read(here('data','Camino_Cielo_Fuelbreak', 'Camino_Cielo_Fuelbreak.shp'))
# 
# LPF <-  sf::st_read(here('data','LPF_Strategic_Fuelbreaks_SMP_CWPP_Final_05012017', 'LPF_Strategic_Fuelbreaks_SMP_CWPP_Final_05012017.shp'))
```
